use std::str::FromStr;
use crate::ast::AST;
use crate::ast::Statement;
use crate::lexer::*;
grammar;

pub Module={
    Function
};

Function: Box<AST> = {"fn" <s:"Identifier"> "(" <l: Comma<Pair>> ")" "->" <t:"Identifier"> <m:Block> => Box::new(AST::Function(s, t,l, m)),
                      "fn" <s:"Identifier"> "(" <l: Comma<Pair>> ")" <m:Block> => Box::new(AST::Function(s, "()".to_string() ,l, m))
                      }

Pair:(String, String) = {<l:"Identifier"> <r:"Identifier"> => (l,r)}

#[inline]
Comma<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};

#[inline]
OneOrMore<T>: Vec<T> = {
    <i1: T> <i2:("," T)*> => {
        let mut items = vec![i1];
        items.extend(i2.into_iter().map(|e| e.1));
        items
    }
};

Statements: Vec<Statement> = {
    Statement*
}

Statement: Statement = {
    VariableDecl,
    If,
    Assignment,
    Block,
    Return,
    While
}


VariableDecl: Statement = {
    "var" <s: "Identifier"> <t:TypeDef> "=" <a:Expr> ";" => Statement::VariableDecl(s ,t, Box::new(Statement::Block(vec![a]))),
    "var" <s: "Identifier"> <t:TypeDef> "=" <a:Statement>     ";" => Statement::VariableDecl(s ,t, Box::new(a)),
    "var" <s: "Identifier"> <t:TypeDef>                   ";" => Statement::VariableDecl(s ,t, Box::new(Statement::Block(vec![]))),
}

TypeDef: Option<String> = {
    (":" <"Identifier">)? => <>.map(|s| s)
}
Block: Statement = {
    "{" <m:Statements> "}" => Statement::Block(m)
}

Expr: Statement = {
    #[precedence(level="0")] 
    Term,
    #[precedence(level="1")] #[assoc(side="right")]
    "!" <e:Expr> => Statement::PreFix('!',Box::new(e)),
    "-" <e:Expr> => Statement::PreFix('-',Box::new(e)),
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => Statement::Math(Box::new(l),'*',Box::new(r)),
    <l:Expr> "/" <r:Expr> => Statement::Math(Box::new(l),'/',Box::new(r)),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => Statement::Math(Box::new(l),'+',Box::new(r)),
    <l:Expr> "-" <r:Expr> => Statement::Math(Box::new(l),'-',Box::new(r)),
    <l:Expr> "==" <r:Expr> => Statement::Math(Box::new(l),'e',Box::new(r)),
    <l:Expr> "!=" <r:Expr> => Statement::Math(Box::new(l),'n',Box::new(r)),
    <l:Expr> "&&" <r:Expr> => Statement::Math(Box::new(l),'a',Box::new(r)),
    <l:Expr> "||" <r:Expr> => Statement::Math(Box::new(l),'o',Box::new(r)),
    <l:Expr> "<" <r:Expr>  => Statement::Math(Box::new(l),'l',Box::new(r)),
    <l:Expr> "<=" <r:Expr> => Statement::Math(Box::new(l),'p',Box::new(r)),
    <l:Expr> ">" <r:Expr>  => Statement::Math(Box::new(l),'g',Box::new(r)),
    <l:Expr> ">=" <r:Expr> => Statement::Math(Box::new(l),'q',Box::new(r)),

}


Term: Statement = {
    #[precedence(level="0")] 
    "Num" => Statement::Num(<>),
    "true"=> Statement::BoolLet(true), 
    "false" => Statement::BoolLet(false),
    "stringlet" => Statement::StringLet(<>),
    #[precedence(level="1")] 
    "Identifier" => Statement::Identifier(<>),
    "("  <Expr> ")" => <> ,
}


If: Statement = {
    "if" "(" <condition:Expr> ")" <stats: Block> <el: Else?> => Statement::If(Box::new(condition), Box::new(stats), Box::new(el.unwrap_or(Statement::Block(vec![]))))
}
Else: Statement = {
    "else" <Block> => <>
}
Return: Statement = {
    "return" <Expr> ";"=> Statement::Return(Box::new(<>)),
}

Assignment: Statement = {
    <name:"Identifier"> "=" <es:Statement> ";" => Statement::Assignment(name.to_string(), Box::new(es)),
    <name:"Identifier"> "=" <e:Expr>   ";"  => Statement::Assignment(name.to_string(), Box::new(Statement::Block(vec![e]))),    
}

While: Statement = {
    "while" <e:Expr> <s:Statement> => Statement::While(Box::new(e), Box::new(s)),
    "loop" <Statement> => Statement::While(Box::new(Statement::BoolLet(true)),Box::new(<>)),
}

extern {
    type Location = usize;
    type Error = LexicalError;
  
    enum Token {
        "fn" => Token::KeywordFn,
        "var" => Token::KeywordVar,
        "if" => Token::KeywordIf,
        "else" => Token::KeywordElse,
        "return" => Token::KeywordReturn,
        "true" => Token::KeywordTrue,
        "false" => Token::KeywordFalse,
        "while" => Token::KeywordWhile,
        "loop" => Token::KeywordLoop,
        "continue" => Token::KeywordContinue,
        "break" => Token::KeywordBreak,


        "Identifier" => Token::Identifier(<String>),
        "Num" => Token::Num(<i64>),
        "stringlet" => Token::StringLet(<String>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        
        "{" => Token::LPrace,
        "}" => Token::RPrace,

        "=" => Token::Assign,
        ";" => Token::Semicolon,
        "," => Token::Comma,
        ":" => Token::Colon,

        "+" => Token::Add,
        "-" => Token::Sub,
        "*" => Token::Mul,
        "/" => Token::Div,

        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "<"  => Token::Less,
        "<="  => Token::LessOrEqual,
        ">"  => Token::Greater,
        ">="  => Token::GreaterOrEqual,
        "!" => Token::Not,
        "&&" => Token::And,
        "||" => Token::Or,
        "->" => Token::Arrow,

    }

}