use std::str::FromStr;
use crate::ast::AST;
use crate::ast::Statement;
grammar;

pub Module={
    Function
};

Function: Box<AST> = {"fn" <s:Identifier> "(" <l: Comma<Pair>> ")" "->" <t:Identifier> <m:Block> => Box::new(AST::Function(s.to_string(), t,l, m)),
                      "fn" <s:Identifier> "(" <l: Comma<Pair>> ")" <m:Block> => Box::new(AST::Function(s.to_string(), "()".to_string() ,l, m))
                      }

Pair:(String, String) = {<l:Identifier> <r:Identifier> => (l,r)}

Identifier: String= {r"[_a-zA-Z][_0-9a-zA-Z]*" => <>.to_string()};

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> r",?")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Statements: Vec<Statement> = {
    Statement*
}

Statement: Statement = {
    Comment,
    VariableDecl,
    If,
    Assignment,
}

Comment: Statement = {
    r"//.+" => Statement::Comment{}
}

VariableDecl: Statement = {
    "var" <s: Identifier> <t:TypeDef> "=" <a:Expr> ";" => Statement::VariableDecl(s,t, Box::new(vec![a])),
    "var" <s: Identifier> <t:TypeDef> "=" <a:Block>     ";" => Statement::VariableDecl(s,t, Box::new(a)),
    "var" <s: Identifier> <t:TypeDef>                   ";" => Statement::VariableDecl(s,t, Box::new(Vec::new())),
}

TypeDef: Option<String> = {
    (":" <Identifier>)? => <>
}
Block: Vec<Statement> = {
    "{" <m:Statements> "}" => m
}

Expr: Statement = {
    #[precedence(level="0")] 
    Term,
    #[precedence(level="1")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => Statement::Math(Box::new(l),'*',Box::new(r)),
    <l:Expr> "/" <r:Expr> => Statement::Math(Box::new(l),'/',Box::new(r)),
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => Statement::Math(Box::new(l),'+',Box::new(r)),
    <l:Expr> "-" <r:Expr> => Statement::Math(Box::new(l),'-',Box::new(r)),
}


Term: Statement = {
    r"[0-9]+" => Statement::Num(i64::from_str(<>).unwrap()),
    r#""(.+)""# => Statement::StringLet(<>[1..<>.len()-1].to_string()),
    <Identifier> => Statement::Identifier(<>),
    "("  <Expr> ")" => <> 
}


If: Statement = {
    "if" "(" <condition:Expr> ")" <stats: Block> <el: Else?> => Statement::If(Box::new(condition), Box::new(stats), Box::new(el.unwrap_or(Vec::new())))
}
Else: Vec<Statement> = {
    "else" <Block> => <>
}
Return: Statement = {
    Expr,
    "return" <Expr> ";"=> <>,
}

Assignment: Statement = {
    <name:Identifier> "=" <es:Block> => Statement::Assignment(name, Box::new(es)),
    <name:Identifier> "=" <e:Expr> => Statement::Assignment(name, Box::new(vec![e])),    
}